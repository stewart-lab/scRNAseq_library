---
title: "Your Title"
output: html_document
---

# ENVIRONMENT SETUP

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(Seurat)
library(patchwork)
library(scran)
library(BiocParallel)
library(DropletUtils)
library(cowplot)
library(harmony)
library(SoupX)
library(scDblFinder)
# SET WD TO THE DIRECTORY WHERE THE SCRIPT IS LOCATED
library(reticulate)
use_condaenv("TESTV5", conda = "/isiseqruns/jfreeman_tmp_home/bin/miniconda3/condabin/conda")
setwd("/isiseqruns/jfreeman_tmp_home/GAMM/scRNAseq_library/")
source("src/sc_pipeline_functions.R")

```
# Load Data


```{r}
data <- read_aligned_data(
  "/w5home/bmoore/scRNAseq/GAMM/output_S1-1_mm_mt/Solo.out/GeneFull/filtered/")
raw_data <- read_aligned_data(
  "/w5home/bmoore/scRNAseq/GAMM/output_S1-1_mm_mt/Solo.out/GeneFull/raw/")
project <- "gamm_s1-1"

data_2 <- read_aligned_data(
  "/w5home/bmoore/scRNAseq/GAMM/output_S1-2_mm_mt/Solo.out/GeneFull/filtered/")
raw_data_2 <- read_aligned_data(
  "/w5home/bmoore/scRNAseq/GAMM/output_S1-2_mm_mt/Solo.out/GeneFull/raw/")
project_2 <- "gamm_s1-2"
```

# Data Prep


```{r}
soupX_objs1 <- prep_seurat_and_soupX(
  data = data, data.raw = raw_data, project = project)

soupX_objs2 <- prep_seurat_and_soupX(
  data = data_2, data.raw = raw_data_2, project = project_2)
```

# Create Seurat objects and convert to sce objects


```{r}
filtered_list_of_objs <- create_seurat_and_sce(
  soupX_objs1$out, soupX_objs2$out)
```


# Post SoupX QC


```{r}
plot1 <- create_feature_scatter_plot(filtered_list_of_objs$gamm1_seu, 'nCount_RNA', 'nFeature_RNA')
plot2 <- create_feature_scatter_plot(filtered_list_of_objs$gamm2_seu, 'nCount_RNA', 'nFeature_RNA')
# save plot object as a pdf 
  pdf(paste0("plot_outputs/post_SoupX_plot.pdf"), width = 8, height = 6)
  plot1 + plot2
dev.off()
```


# Doublet removal and lane merging


```{r}
lane_and_merged_gamm <- run_scDblFinder_and_merge(
  filtered_list_of_objs$sce1, filtered_list_of_objs$sce2)
```

# Post Doublet removal QC


```{r}
plot <- create_feature_scatter_plot(lane_and_merged_gamm$gamm, 'nCount_RNA', 'nFeature_RNA')
  pdf(paste0("plot_outputs/after_dbl_removal.pdf"), width = 8, height = 6)
  plot
dev.off()
```

# Mitochondrial gene filtering


```{r}
pig_mt_list <- c("ND1","ND2", "COX1", "COX2", "ATP8", "ATP6", "COX3", "ND3", "ND4L", "ND4", "ND5", "ND6", "CYTB")
gamm_mt_filtered <- filter_cells(lane_and_merged_gamm$gamm, pig_mt_list)

```
# Housekeeping and plots


```{r}
plot1 <- create_feature_scatter_plot(gamm_mt_filtered, 'nCount_RNA', 'percent.mt')
plot2 <- create_feature_scatter_plot(gamm_mt_filtered, 'nCount_RNA', 'nFeature_RNA')

  pdf(paste0("plot_outputs/mt_filtered.pdf"), width = 8, height = 6)
  plot1 + plot2
dev.off()


rm(gamm1, gamm2, sce1, sce2, raw_data, raw_data_2, data, data_2, obj1_to_write, obj2_to_write, ambiant_filtered1, ambiant_filtered2, lane_and_merged_gamm)

```


# Normalization


```{r}
normalized_gamm <- normalize_data(gamm_mt_filtered)
```

# Post Normalization QC (violin plots)


```{r}

```


# Feature selection

```{r}
feature_selected_gamm <- feature_selection(normalized_gamm, 'Scry')
```


# Scaling data

```{r}
scaled_gamm <- scale_data(feature_selected_gamm)
```

# Post scaling QC (violin plots)

```{r}

```

# Dimensional reduction

```{r}
pca_outputs <- run_and_visualize_pca(scaled_gamm)

pdf(paste0("plot_outputs/feature_loadings.pdf"), width = 8, height = 6)
pca_outputs$feature_loadings
dev.off()

pdf(paste0("plot_outputs/pca_scatter_plot.pdf"), width = 8, height = 6)
pca_outputs$pca_scat_plot
dev.off()

pdf(paste0("plot_outputs/pca_heat_map.pdf"), width = 8, height = 6)
pca_outputs$pca_heat_map
dev.off()

seurat_obj <- pca_outputs$seurat_obj
```

# Batch correction
```{r}
batch_corrected_obj_and_plots <- perform_batch_correction(seurat_obj)

```
```{r}
clustered_seurat_obj <- perform_clustering(batch_corrected_obj_and_plots$seurat_obj)
```
```{r}
```
```{r}
gamm@meta.data$lanes <- c(rep("lane1", lane1_mt_filtered_cells), rep("lane2", lane2_mt_filtered_cells))
# check PCA plot
options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = gamm, reduction = "pca", pt.size = .1, group.by = "lanes")
p2 <- VlnPlot(object = gamm, features = "PC_1", group.by = "lanes", pt.size = .1)
plot_grid(p1,p2)
# run harmony
options(repr.plot.height = 2.5, repr.plot.width = 6)
gamm <- gamm %>% 
  RunHarmony("lanes", plot_convergence = TRUE)
# access harmony embeddings
harmony_embeddings <- Embeddings(gamm, 'harmony')
harmony_embeddings[1:5, 1:5]
# check out new pca plot
options(repr.plot.height = 5, repr.plot.width = 12)
p1 <- DimPlot(object = gamm, reduction = "harmony", pt.size = .1, group.by = "lanes")
p2 <- VlnPlot(object = gamm, features = "harmony_1", group.by = "lanes", pt.size = .1)
plot_grid(p1,p2)

# Determine the ‘dimensionality’ of the dataset
# to overcome technical noise, Seurat clusters cells based on their PCA scores, 
# with each PC essentially representing a ‘metafeature’ that combines information 
# across a correlated feature set. The top principal components therefore represent 
# a robust compression of the dataset
# JackStraw randomly permutes a subset (1%) of the data and reruns PCA, constructing a null
# distribution of feature scores. Significant PCs have strong enrichment of low p-val features


gamm <- JackStraw(gamm, num.replicate = 100)
gamm <- ScoreJackStraw(gamm, dims = 1:20)
# The JackStrawPlot() function provides a visualization tool for comparing the 
# distribution of p-values for each PC with a uniform distribution (dashed line). 
# ‘Significant’ PCs will show a strong enrichment of features with low p-values 
#(solid curve above the dashed line).
JackStrawPlot(gamm, dims = 1:20)
#  alternative heuristic method generates an ‘Elbow plot’: a ranking of principle 
# components based on the percentage of variance explained by each one (ElbowPlot() 
# function). In this example, we can observe an ‘elbow’ to suggest how many PCs capture
# the majority of the true signal. can use reduction='harmony' to use harmony embeddings
ElbowPlot(gamm, reduction='harmony')
ElbowPlot(gamm, reduction='pca')
# Cluster the Cells using only genes from chosen PCs
# to use harmony embeddings pass reduction='harmony'
# K-nearest neighbor (KNN) graph
gamm <- FindNeighbors(gamm, dims = 1:15, reduction='harmony')
# check harmony umap for differences across lanes
gamm <- RunUMAP(gamm, dims = 1:15, reduction = "harmony")
options(repr.plot.height = 4, repr.plot.width = 10)
DimPlot(gamm, reduction = "umap", group.by = "lanes", pt.size = .1)#, split.by = 'lanes')
# note need to pip install leiden and pandas for FindClusters to run
#reticulate::py_install(packages ='leidenalg') #pip install leidenalg
#reticulate::py_install(packages ='pandas')
gamm <- FindClusters(gamm, resolution = 0.5, algorithm = "leiden")
# Look at cluster IDs of the first 5 cells
head(Idents(gamm), 5)
```

# Non linear dimensional reduction
```{r}
# Run non-linear dimensional reduction (UMAP/tSNE)
# The goal of these algorithms is to learn the underlying manifold of the data in order 
# to place similar cells together in low-dimensional space. Cells within the graph-based 
# clusters determined above should co-localize on these dimension reduction plots. 
# As input to the UMAP and tSNE, we suggest using the same PCs as input to the 
# clustering analysis.
# If you haven't installed UMAP: 
# reticulate::py_install(packages ='umap-learn')
#gamm <- RunUMAP(gamm, dims = 1:15)
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# plot individual clusters
DimPlot(gamm, reduction = "umap", label = T)
# save object
saveRDS(gamm, file = "GAMM_test1_lanes.rds")
# read back in the object
gamm <- readRDS(file = "GAMM_test1.rds")
```

# Differential expression
```{r}
# find all markers of cluster 1 compared to all other clusters
cluster1.markers <- FindMarkers(gamm, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)
# find all markers distinguishing cluster 5 from clusters 0 and 3
#cluster5.markers <- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(cluster5.markers, n = 5)
# find markers for every cluster compared to all remaining cells, report only the positive
# ones
gamm.markers <- FindAllMarkers(gamm, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
gamm.markers %>%
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC) %>%
  print(n=28)
# ROC test for cluster markers, 0= random, 1= perfect)
cluster1.markers <- FindMarkers(gamm, ident.1 = 1, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
head(cluster1.markers, n = 5)
# visualize marker expression
VlnPlot(gamm, features = c("SFRP2", "TRPM3"))
# you can plot raw counts as well
VlnPlot(gamm, features = c("SFRP2", "TRPM3"), slot = "counts", log = TRUE)
# umap plot highlighting gene expression
FeaturePlot(gamm, features = c("SFRP2", "TRPM3", "ENSSSCG00065027583", "SST"),label = TRUE)
# DoHeatmap() generates an expression heatmap for given cells and features. 
# In this case, we are plotting the top 20 markers
gamm.markers %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log2FC) -> top10
DoHeatmap(gamm, features = top10$gene) + NoLegend()
```

# Assigning cell type identity to clusters
```{r}
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
                     "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
# save object
saveRDS(pbmc, file = "output/pbmc3k_final.rds")
sessionInfo()
```

